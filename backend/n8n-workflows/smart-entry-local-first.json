{
  "name": "Nexus: Smart Entry (Local First, Claude Fallback)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "nexus",
        "responseMode": "responseNode", "options": {}
      },
      "id": "webhook",
      "name": "Universal Webhook",
      "type": "n8n-nodes-base.webhook",
      "position": [240, 300],
      "webhookId": "nexus",
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "// ============================================================================\n// LOCAL PARSER - No Claude needed for common patterns\n// ============================================================================\n\nconst input = ($input.first().json.body?.text || $input.first().json.text || '').trim();\nconst source = $input.first().json.body?.source || 'webhook';\n\n// Pattern definitions\nconst patterns = {\n  weight: [\n    { regex: /^w\\s*(\\d+\\.?\\d*)/i, extract: (m) => ({ weight_kg: parseFloat(m[1]) }) },\n    { regex: /^weight\\s*(\\d+\\.?\\d*)/i, extract: (m) => ({ weight_kg: parseFloat(m[1]) }) },\n    { regex: /^(\\d+\\.?\\d*)\\s*kg/i, extract: (m) => ({ weight_kg: parseFloat(m[1]) }) },\n  ],\n  water: [\n    { regex: /^water$/i, extract: () => ({ amount_ml: 250 }) },\n    { regex: /^(\\d+)\\s*ml/i, extract: (m) => ({ amount_ml: parseInt(m[1]) }) },\n    { regex: /^(\\d+)\\s*glass/i, extract: (m) => ({ amount_ml: parseInt(m[1]) * 250 }) },\n  ],\n  mood: [\n    { regex: /^m\\s*(\\d+)\\s*(\\d+)?/i, extract: (m) => ({ mood: parseInt(m[1]), energy: m[2] ? parseInt(m[2]) : null }) },\n    { regex: /^mood\\s*(\\d+)/i, extract: (m) => ({ mood: parseInt(m[1]) }) },\n  ],\n  habit: [\n    { regex: /^done\\s+(.+)/i, extract: (m) => ({ habit_name: m[1] }) },\n    { regex: /^did\\s+(.+)/i, extract: (m) => ({ habit_name: m[1] }) },\n    { regex: /^(\\w+)\\s+done$/i, extract: (m) => ({ habit_name: m[1] }) },\n  ],\n  supplement: [\n    { regex: /^took\\s+(.+)/i, extract: (m) => ({ name: m[1] }) },\n    { regex: /^(creatine|vitamin|omega|magnesium|zinc)/i, extract: (m) => ({ name: m[1] }) },\n  ],\n  quickFood: [\n    { regex: /^coffee$/i, extract: () => ({ description: 'coffee', calories: 5, protein_g: 0 }) },\n    { regex: /^coffee\\s+with\\s+milk/i, extract: () => ({ description: 'coffee with milk', calories: 30, protein_g: 1 }) },\n    { regex: /^(\\d+)\\s*eggs?/i, extract: (m) => ({ description: `${m[1]} eggs`, calories: parseInt(m[1]) * 78, protein_g: parseInt(m[1]) * 6 }) },\n    { regex: /^banana/i, extract: () => ({ description: 'banana', calories: 105, protein_g: 1 }) },\n    { regex: /^apple/i, extract: () => ({ description: 'apple', calories: 95, protein_g: 0 }) },\n    { regex: /^protein\\s*shake/i, extract: () => ({ description: 'protein shake', calories: 150, protein_g: 30 }) },\n  ],\n  shopping: [\n    { regex: /^add\\s+(.+?)\\s+to\\s+(?:shopping\\s+)?list/i, extract: (m) => ({ items: m[1].split(/,|and/).map(s => s.trim()) }) },\n    { regex: /^buy\\s+(.+)/i, extract: (m) => ({ items: m[1].split(/,|and/).map(s => s.trim()) }) },\n  ],\n};\n\n// Try to match patterns\nfor (const [type, typePatterns] of Object.entries(patterns)) {\n  for (const { regex, extract } of typePatterns) {\n    const match = input.match(regex);\n    if (match) {\n      return {\n        parsed: true,\n        type,\n        data: extract(match),\n        source,\n        original: input,\n        usedClaude: false\n      };\n    }\n  }\n}\n\n// No pattern matched - needs Claude\nreturn {\n  parsed: false,\n  original: input,\n  source,\n  usedClaude: true\n};"
      },
      "id": "local-parse",
      "name": "Local Parser",
      "type": "n8n-nodes-base.code",
      "position": [460, 300],
      "typeVersion": 2
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [{ "value1": "={{ $json.parsed }}", "value2": true }]
        }
      },
      "id": "was-parsed",
      "name": "Parsed Locally?",
      "type": "n8n-nodes-base.if",
      "position": [680, 300],
      "typeVersion": 1
    },
    {
      "parameters": {
        "url": "https://api.anthropic.com/v1/messages",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"claude-sonnet-4-20250514\",\n  \"max_tokens\": 512,\n  \"messages\": [{\n    \"role\": \"user\",\n    \"content\": \"Parse this for a life tracking database. Return JSON only: {type, data, response}\\n\\nTypes: food (with calories/protein estimate), water, weight, mood, habit, supplement, shopping, query\\n\\nInput: {{ $json.original }}\"\n  }]\n}",
        "options": {}
      },
      "id": "claude-fallback",
      "name": "Claude Fallback",
      "type": "n8n-nodes-base.httpRequest",
      "position": [900, 400],
      "typeVersion": 4.2,
      "credentials": {
        "httpHeaderAuth": {
          "id": "REPLACE_WITH_ANTHROPIC_CREDENTIAL",
          "name": "Anthropic API"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse Claude's response\ntry {\n  const content = $input.first().json.content?.[0]?.text || '';\n  const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    const parsed = JSON.parse(jsonMatch[0]);\n    return { ...parsed, usedClaude: true, parsed: true };\n  }\n} catch (e) {}\n\n// Claude failed too - return error\nreturn {\n  parsed: false,\n  type: 'error',\n  response: 'Could not understand. Try: \"2 eggs\", \"w 75.5\", \"water\", \"m 7 6\"',\n  usedClaude: true\n};"
      },
      "id": "parse-claude",
      "name": "Parse Claude",
      "type": "n8n-nodes-base.code",
      "position": [1120, 400],
      "typeVersion": 2
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "merge",
      "name": "Merge Results",
      "type": "n8n-nodes-base.merge",
      "position": [1340, 300],
      "typeVersion": 3
    },
    {
      "parameters": {
        "rules": {
          "rules": [
            { "outputKey": "food", "value1": "={{ $json.type }}", "value2": "food" },
            { "outputKey": "quickFood", "value1": "={{ $json.type }}", "value2": "quickFood" },
            { "outputKey": "water", "value1": "={{ $json.type }}", "value2": "water" },
            { "outputKey": "weight", "value1": "={{ $json.type }}", "value2": "weight" },
            { "outputKey": "mood", "value1": "={{ $json.type }}", "value2": "mood" },
            { "outputKey": "habit", "value1": "={{ $json.type }}", "value2": "habit" },
            { "outputKey": "supplement", "value1": "={{ $json.type }}", "value2": "supplement" },
            { "outputKey": "shopping", "value1": "={{ $json.type }}", "value2": "shopping" },
            { "outputKey": "error", "value1": "={{ $json.type }}", "value2": "error" }
          ]
        }
      },
      "id": "route",
      "name": "Route by Type",
      "type": "n8n-nodes-base.switch",
      "position": [1560, 300],
      "typeVersion": 3
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO nutrition.food_log (date, meal_time, description, calories, protein_g, source, confidence)\nVALUES ((NOW() AT TIME ZONE 'Asia/Dubai')::date,\n  CASE WHEN EXTRACT(HOUR FROM NOW() AT TIME ZONE 'Asia/Dubai') < 10 THEN 'breakfast'\n       WHEN EXTRACT(HOUR FROM NOW() AT TIME ZONE 'Asia/Dubai') < 14 THEN 'lunch'\n       WHEN EXTRACT(HOUR FROM NOW() AT TIME ZONE 'Asia/Dubai') < 17 THEN 'snack'\n       ELSE 'dinner' END,\n  '{{ $json.data.description }}',\n  {{ $json.data.calories || 'NULL' }},\n  {{ $json.data.protein_g || 'NULL' }},\n  '{{ $json.source }}',\n  '{{ $json.usedClaude ? \"medium\" : \"high\" }}'\n) RETURNING id, calories, protein_g;",
        "options": {}
      },
      "id": "insert-food",
      "name": "Insert Food",
      "type": "n8n-nodes-base.postgres",
      "position": [1780, 100],
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "p5cyLWCZ9Db6GiiQ", "name": "Nexus DB" } }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO nutrition.water_log (date, amount_ml, source) VALUES ((NOW() AT TIME ZONE 'Asia/Dubai')::date, {{ $json.data.amount_ml }}, '{{ $json.source }}');",
        "options": {}
      },
      "id": "insert-water",
      "name": "Insert Water",
      "type": "n8n-nodes-base.postgres",
      "position": [1780, 200],
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "p5cyLWCZ9Db6GiiQ", "name": "Nexus DB" } }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO health.metrics (recorded_at, date, source, metric_type, value, unit)\nVALUES (NOW(), (NOW() AT TIME ZONE 'Asia/Dubai')::date, '{{ $json.source }}', 'weight', {{ $json.data.weight_kg }}, 'kg');",
        "options": {}
      },
      "id": "insert-weight",
      "name": "Insert Weight",
      "type": "n8n-nodes-base.postgres",
      "position": [1780, 300],
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "p5cyLWCZ9Db6GiiQ", "name": "Nexus DB" } }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO core.daily_journal (date, mood_score, energy_score)\nVALUES ((NOW() AT TIME ZONE 'Asia/Dubai')::date, {{ $json.data.mood || 'NULL' }}, {{ $json.data.energy || 'NULL' }})\nON CONFLICT (date) DO UPDATE SET\n  mood_score = COALESCE(EXCLUDED.mood_score, core.daily_journal.mood_score),\n  energy_score = COALESCE(EXCLUDED.energy_score, core.daily_journal.energy_score);",
        "options": {}
      },
      "id": "insert-mood",
      "name": "Insert Mood",
      "type": "n8n-nodes-base.postgres",
      "position": [1780, 400],
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "p5cyLWCZ9Db6GiiQ", "name": "Nexus DB" } }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=INSERT INTO activity.habit_log (habit_id, date, completed)\nSELECT id, (NOW() AT TIME ZONE 'Asia/Dubai')::date, TRUE FROM activity.habits\nWHERE LOWER(name) LIKE LOWER('%{{ $json.data.habit_name }}%') AND is_active = TRUE\nLIMIT 1\nON CONFLICT (habit_id, date) DO UPDATE SET completed = TRUE;",
        "options": {}
      },
      "id": "insert-habit",
      "name": "Insert Habit",
      "type": "n8n-nodes-base.postgres",
      "position": [1780, 500],
      "typeVersion": 2.5,
      "credentials": { "postgres": { "id": "p5cyLWCZ9Db6GiiQ", "name": "Nexus DB" } }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": true,\n  \"type\": \"{{ $json.type }}\",\n  \"data\": {{ JSON.stringify($json.data) }},\n  \"usedClaude\": {{ $json.usedClaude || false }},\n  \"response\": \"{{ $json.response || 'Logged successfully' }}\"\n}"
      },
      "id": "respond",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "position": [2000, 300],
      "typeVersion": 1.1
    }
  ],
  "connections": {
    "Universal Webhook": { "main": [[{ "node": "Local Parser", "type": "main", "index": 0 }]] },
    "Local Parser": { "main": [[{ "node": "Parsed Locally?", "type": "main", "index": 0 }]] },
    "Parsed Locally?": {
      "main": [
        [{ "node": "Merge Results", "type": "main", "index": 0 }],
        [{ "node": "Claude Fallback", "type": "main", "index": 0 }]
      ]
    },
    "Claude Fallback": { "main": [[{ "node": "Parse Claude", "type": "main", "index": 0 }]] },
    "Parse Claude": { "main": [[{ "node": "Merge Results", "type": "main", "index": 1 }]] },
    "Merge Results": { "main": [[{ "node": "Route by Type", "type": "main", "index": 0 }]] },
    "Route by Type": {
      "main": [
        [{ "node": "Insert Food", "type": "main", "index": 0 }],
        [{ "node": "Insert Food", "type": "main", "index": 0 }],
        [{ "node": "Insert Water", "type": "main", "index": 0 }],
        [{ "node": "Insert Weight", "type": "main", "index": 0 }],
        [{ "node": "Insert Mood", "type": "main", "index": 0 }],
        [{ "node": "Insert Habit", "type": "main", "index": 0 }],
        [{ "node": "Respond", "type": "main", "index": 0 }],
        [{ "node": "Respond", "type": "main", "index": 0 }],
        [{ "node": "Respond", "type": "main", "index": 0 }]
      ]
    },
    "Insert Food": { "main": [[{ "node": "Respond", "type": "main", "index": 0 }]] },
    "Insert Water": { "main": [[{ "node": "Respond", "type": "main", "index": 0 }]] },
    "Insert Weight": { "main": [[{ "node": "Respond", "type": "main", "index": 0 }]] },
    "Insert Mood": { "main": [[{ "node": "Respond", "type": "main", "index": 0 }]] },
    "Insert Habit": { "main": [[{ "node": "Respond", "type": "main", "index": 0 }]] }
  },
  "settings": { "executionOrder": "v1" },
  "tags": [{ "name": "nexus" }]
}
