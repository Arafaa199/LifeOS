{
  "name": "Nexus: Reminders Sync Webhook (Bidirectional)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "nexus-reminders-sync",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook",
      "name": "Reminders Sync Webhook",
      "type": "n8n-nodes-base.webhook",
      "position": [200, 300],
      "webhookId": "nexus-reminders-sync",
      "typeVersion": 2
    },
    {
      "parameters": {
        "jsCode": "const body = $input.first().json.body || $input.first().json;\nconst source = body.source || 'ios_eventkit';\nconst clientId = body.client_id || null;\nconst reminders = body.reminders || [];\nconst syncedIds = (body.synced_reminder_ids || []);\n\nif (!Array.isArray(reminders) || reminders.length === 0) {\n  return { json: { upsertSql: 'SELECT 1', absenceSql: 'SELECT 1', count: 0 } };\n}\n\nconst esc = (v) => v == null ? null : String(v).replace(/'/g, \"''\");\n\nconst vals = reminders.map(r => {\n  const rid = esc(r.reminder_id);\n  if (!rid) return null;\n  const title = r.title != null ? \"'\" + esc(r.title) + \"'\" : 'NULL';\n  const notes = r.notes != null ? \"'\" + esc(r.notes) + \"'\" : 'NULL';\n  const dueDate = r.due_date ? \"'\" + esc(r.due_date) + \"'::timestamptz\" : 'NULL';\n  const isCompleted = r.is_completed ? 'true' : 'false';\n  const completedDate = r.completed_date ? \"'\" + esc(r.completed_date) + \"'::timestamptz\" : 'NULL';\n  const priority = Number.isInteger(r.priority) ? r.priority : 0;\n  const listName = r.list_name != null ? \"'\" + esc(r.list_name) + \"'\" : 'NULL';\n  const cid = clientId ? \"'\" + esc(clientId) + \"'::uuid\" : 'NULL';\n  const src = \"'\" + esc(source) + \"'\";\n  const ekModAt = r.eventkit_modified_at ? \"'\" + esc(r.eventkit_modified_at) + \"'::timestamptz\" : 'NULL';\n  return `('${rid}', ${title}, ${notes}, ${dueDate}, ${isCompleted}, ${completedDate}, ${priority}, ${listName}, ${cid}, ${src}, ${ekModAt}, CURRENT_TIMESTAMP, 'eventkit')`;\n}).filter(v => v !== null);\n\nif (vals.length === 0) {\n  return { json: { upsertSql: 'SELECT 1', absenceSql: 'SELECT 1', count: 0 } };\n}\n\n// Diff-aware upsert: only update if EK is newer (eventkit_modified_at > existing)\nconst upsertSql = `INSERT INTO raw.reminders (\n  reminder_id, title, notes, due_date, is_completed,\n  completed_date, priority, list_name, client_id, source,\n  eventkit_modified_at, last_seen_at, origin\n)\nVALUES ${vals.join(',\\n')}\nON CONFLICT (reminder_id, source) DO UPDATE SET\n  title = CASE WHEN EXCLUDED.eventkit_modified_at IS NULL OR raw.reminders.eventkit_modified_at IS NULL\n               OR EXCLUDED.eventkit_modified_at > raw.reminders.eventkit_modified_at\n               THEN EXCLUDED.title ELSE raw.reminders.title END,\n  notes = CASE WHEN EXCLUDED.eventkit_modified_at IS NULL OR raw.reminders.eventkit_modified_at IS NULL\n               OR EXCLUDED.eventkit_modified_at > raw.reminders.eventkit_modified_at\n               THEN EXCLUDED.notes ELSE raw.reminders.notes END,\n  due_date = CASE WHEN EXCLUDED.eventkit_modified_at IS NULL OR raw.reminders.eventkit_modified_at IS NULL\n                  OR EXCLUDED.eventkit_modified_at > raw.reminders.eventkit_modified_at\n                  THEN EXCLUDED.due_date ELSE raw.reminders.due_date END,\n  is_completed = CASE WHEN EXCLUDED.eventkit_modified_at IS NULL OR raw.reminders.eventkit_modified_at IS NULL\n                      OR EXCLUDED.eventkit_modified_at > raw.reminders.eventkit_modified_at\n                      THEN EXCLUDED.is_completed ELSE raw.reminders.is_completed END,\n  completed_date = CASE WHEN EXCLUDED.eventkit_modified_at IS NULL OR raw.reminders.eventkit_modified_at IS NULL\n                        OR EXCLUDED.eventkit_modified_at > raw.reminders.eventkit_modified_at\n                        THEN EXCLUDED.completed_date ELSE raw.reminders.completed_date END,\n  priority = CASE WHEN EXCLUDED.eventkit_modified_at IS NULL OR raw.reminders.eventkit_modified_at IS NULL\n                  OR EXCLUDED.eventkit_modified_at > raw.reminders.eventkit_modified_at\n                  THEN EXCLUDED.priority ELSE raw.reminders.priority END,\n  list_name = CASE WHEN EXCLUDED.eventkit_modified_at IS NULL OR raw.reminders.eventkit_modified_at IS NULL\n                   OR EXCLUDED.eventkit_modified_at > raw.reminders.eventkit_modified_at\n                   THEN EXCLUDED.list_name ELSE raw.reminders.list_name END,\n  eventkit_modified_at = CASE WHEN EXCLUDED.eventkit_modified_at IS NULL OR raw.reminders.eventkit_modified_at IS NULL\n                              OR EXCLUDED.eventkit_modified_at > raw.reminders.eventkit_modified_at\n                              THEN EXCLUDED.eventkit_modified_at ELSE raw.reminders.eventkit_modified_at END,\n  last_seen_at = CURRENT_TIMESTAMP,\n  sync_status = CASE WHEN raw.reminders.sync_status = 'pending_push' THEN 'pending_push' ELSE 'synced' END\nWHERE raw.reminders.deleted_at IS NULL;`;\n\n// Absence detection: mark reminders not in this batch as deleted_remote\n// Only if they were previously synced and last_seen recently (within fetch window)\nconst seenIds = reminders.map(r => \"'\" + esc(r.reminder_id) + \"'\").join(',');\nconst absenceSql = `UPDATE raw.reminders SET\n  sync_status = 'deleted_remote',\n  deleted_at = CURRENT_TIMESTAMP\nWHERE source = '${esc(source)}'\n  AND reminder_id NOT IN (${seenIds})\n  AND sync_status = 'synced'\n  AND deleted_at IS NULL\n  AND last_seen_at > CURRENT_TIMESTAMP - interval '2 hours';`;\n\nreturn { json: { upsertSql, absenceSql, count: vals.length } };"
      },
      "id": "build-sql",
      "name": "Build SQL",
      "type": "n8n-nodes-base.code",
      "position": [420, 300],
      "typeVersion": 2
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.upsertSql }}",
        "options": {}
      },
      "id": "upsert",
      "name": "Upsert Reminders",
      "type": "n8n-nodes-base.postgres",
      "position": [640, 300],
      "typeVersion": 2.5,
      "credentials": {
        "postgres": {
          "id": "p5cyLWCZ9Db6GiiQ",
          "name": "Nexus PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $('Build SQL').item.json.absenceSql }}",
        "options": {}
      },
      "id": "absence",
      "name": "Mark Absent as Deleted",
      "type": "n8n-nodes-base.postgres",
      "position": [860, 300],
      "typeVersion": 2.5,
      "credentials": {
        "postgres": {
          "id": "p5cyLWCZ9Db6GiiQ",
          "name": "Nexus PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": true,\n  \"inserted\": {\n    \"reminders\": {{ $('Build SQL').item.json.count }}\n  },\n  \"timestamp\": \"{{ new Date().toISOString() }}\"\n}",
        "options": {}
      },
      "id": "respond",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "position": [1080, 300],
      "typeVersion": 1.1
    }
  ],
  "connections": {
    "Reminders Sync Webhook": {
      "main": [[{ "node": "Build SQL", "type": "main", "index": 0 }]]
    },
    "Build SQL": {
      "main": [[{ "node": "Upsert Reminders", "type": "main", "index": 0 }]]
    },
    "Upsert Reminders": {
      "main": [[{ "node": "Mark Absent as Deleted", "type": "main", "index": 0 }]]
    },
    "Mark Absent as Deleted": {
      "main": [[{ "node": "Respond to Webhook", "type": "main", "index": 0 }]]
    }
  },
  "settings": { "executionOrder": "v1" },
  "tags": [{ "name": "nexus" }],
  "meta": {
    "notes": "Reminders bidirectional sync webhook â€” diff-aware upsert + absence detection.\nEndpoint: POST /webhook/nexus-reminders-sync\nPayload: { client_id, source, reminders: [{reminder_id, title, notes, due_date, is_completed, completed_date, priority, list_name, eventkit_modified_at}] }\nDiff logic: Only updates fields if eventkit_modified_at > existing. Marks absent reminders as deleted_remote."
  }
}
